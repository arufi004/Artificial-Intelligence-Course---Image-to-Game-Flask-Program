# Artificial-Intelligence-Course---Image-to-Game-Flask-Program

Name:  	 	 	      Anthony Rufin 
Panther ID:  	 	 	6227314 
Class:  	 	 	    CAP5602 U01C 1255 - Introduction to Artificial Intelligence 
Homework:   	 	  HW1 - Search 
Due:   	 	 	      June 11, 2025 
What is this program? 	This program is an 8-Puzzle Game generator. It takes an image from the user and turns it into a 3x3 tile puzzle. This program can also reshuffle the puzzle, and generate a list of steps to reach the goal state of the puzzle. 
 
File Structure: 
HW1-Search: 
 	templates/ 
  index.html -> This is the html file holding the main html code for the flask web application 
 	static/  	 	styles.css -> This is a stylesheet for the website.  	app.py -> This is the main project file, used to host the flask program.  	uploadImage.py -> this is a file used to manage uploaded images  	puzzle.py -> This is a file to manage the puzzle generation and shuffling  	solve.py -> This is a file for managing the A* Algorithm and Manhattan Distance functions for generating solutions  	run.py -> A Helper file used to create the app.route for the executable file. 
 
Use the run.exe to run the program. 
 
Libraries used: 
Flask - For creating the web application, uses Flask, render_template, request, redirect, url_for, send_from_directory os - For generating the folder to store images in the web application random - For scrambling the puzzle a random number of times uuid - For generating unique names for each images, allowing for images with the same name to be stored 
Pillow - For Image Handling, processing, and resizing. For more information, see this website: https://pypi.org/project/pillow/ heapq - For creating the heap used in the A* Algorithm solver 
 
------------------------------------------------------------------------------------------------------------------ 
 
app.py app.py is the main file for this project. It uses flask to create a webpage to host the puzzle. app.py has two routes: @app.route('/uploads/<filename>') def uploaded_file(filename): and @app.route('/', methods=['GET', 'POST']) def index():. The former is just an app route for handling uploaded images, while the latter controls the route for the website.  
When there is no image, it renders the template created by the index.html file, showing a blank screen with the option to upload an image and create a puzzle. After uploading a valid image (png, jpg, etc.) and creating the puzzle, it will then render the puzzle screen, with the complete image sliced into segments. Pressing Shuffle calls the shuffle function, and shuffles the image to create the puzzle. Pressing the arrow keys will swap the position of the empty tile with an adjacent tile in that direction. Lastly, the solve button will generate a list of instructions that will show what steps are needed to reach the goal state. 
 
------------------------------------------------------------------------------------------------------------------ uploadImage.py uploadImage.py only has one function, handle_uploaded_image(file, upload_folder). handle_uploaded_image(file, upload_folder), takes a file (the image), and the folder the image is stored in on the web application (static/uploaded_images).  
The purpose of this python file is to handle all image uploads and preprocessing.  
The image is resized to 600 by 600 to ensure consistency among all puzzles, and to ensure clean division into a 3x3 grid. UUIDs are generated to ensure that multiple uploads of similar images would not cause any errors. The uuid, os, and Pillow libraries are used for this part of the program 
 
------------------------------------------------------------------------------------------------------------------ 
 
puzzle.py puzzle.py is the main file for the game logic. It contains the class PuzzleGame, and imports the pillow library, along with random. 
First, there is the constructor function for this class. It takes an image path, and initializes the board, the size of each tile, the correctly ordered board, an empty position list, which tracks the position of the empty tile, and the sliced images (called tiles in the program).  
The Empty position list, also known as empty_position, is created for the sole purpose of tracking the empty tile. This is to ensure that the game can know where to swap the empty tile with whichever tile is placed into that position.  
Board is a variable to represent the puzzle state. It is represented as a 3x3 matrix 
 
slice_image is a function for taking the image from the file path generated by handle_uploaded_image, and, iterating over 3 rows and 3 columns, creates bounding boxes for each tile, using img.crop() to extract each tile. By slicing the image before the game starts, it improves the performance of the game. 
 
get_state is a dictionary that returns the current bard state. It contains the current board state, the position of the empty tile, and a Boolean for whether the puzzle was solved. This is used as an easy way to fetch the current game state, and is used to render the game state, see if the game has been completed, and calculating the most optimal solution based on the current game state. 
 
move_tile is a function that swaps a tile with the empty tile. Using the empty_position variable, we can create directional movement. The program first gets the empty tile, checks if the move is valid, and if it is valid, swaps the empty tile with the adjacent tile in the given direction. Since the state is updated in the function, it improves the performance of the game by directly modifying the board to reflect the new state. 
 
shuffle is a function used to shuffle the board. This is achieved by randomly selecting moves 100 times, to ensure sufficient scrambling. By making it so the program has to use the move function, it ensures the program generates puzzles that are actually solvable, since it can only use moves the player can also use. 
 
get_flat_board is a function that converts the board into a list. This is mostly used for the solver file, as the A* algorithm will be using this flat list for easier state hashing. 
 
apply_flat_board is a function that takes a flat list and uses it to update the puzzle state. This is a function mostly used by the solver's A* algorithm to assess the most optimal solution to solve the puzzle using the puzzle's state when called. 
 
------------------------------------------------------------------------------------------------------------------ 
 
solver.py 
solver.py is a file created to find optimal solutions using the A8 algorithm with the Manhattan Distance heuristic. solver.py has 3 functions: manhattan_distance, get_neighbors, and solve_puzzle. 
 
Manhattan Distance was used over other heuristics due to the fact that it is consistent and more informed than other heuristics, such as misplaced tiles. It tends to create fewer nodes than Misplaced tiles at the cost of slightly higher cost of calculation, but ensures that the program is more well informed about how far the current state is to the goal state, something misplaced tiles has a hard time accomplishing. It was chosen over Euclidean distance as Euclidean distance overestimates diagonal moves, something that this program is unable to do. Other heuristics were either too complex or were too underpowered, thus leaving Manhattan as the best choice for computational cost vs performance. 
 
manhattan_distance is a function for running the calculations to find the Manhattan distance for the tiles, by finding the sum of distances of each tile from their goal position. As stated previously, I chose Manhattan distance due to the fact that it creates the fewest nodes compared to its cost of calculation. The way this is doe is by iterating over the values of each tile (represented as 0-7), and calculating the distance of each tile by finding the absolute value of the position subtracted by the target. For instance if tile 5 (the tile that should be at row 1, column 2) is at row 0, column 0, then the Manhattan distance of that tile is the absolute value of 0 - 1 added to the absolute value of 0 - 2.  
 
get_neighbors is a function that generates valid moves from a given state. This is done using the empty tile's position and a list of tuples, containing the new state and the move needed to reach that state. It converts the index of row and col into two dimensional coordinates and proceeds to calculate the possible movements the empty tile could make. It also checks that the tile stays within the bounds of the board, and filters out invalid moves, such as moving up at the top of the board. Lastly, it makes a copy of the current state by creating a 1-dimensional index of the swap position and allows the empty tile to swap with the adjacent tile if it passed the movement checks. It then stores this in a neighborâ€™s index, which is returned at the end of the function, the index now containing all valid neighbors of the tile.  
 
solve_puzzle is the function that solves the puzzle using the A* algorithm. First, the board is converted into a flat tuple, and the goal state is defined. Using a priority queue, open_set, a minimum heap is created, prioritizing states with lowest f_score. The came_from dictionary records the parent state and the move. g_score tracks actual cost from start to each state, while f_score stores the g_score + Manhattan distance for each state.  
The man loop of the program checks for the best path to take, after extracting the lowest f_score. We continue until we reach the goal, in which the path is reconstructed by backtracking through the came_from dictionary. For each neighbor, we calculate the new path cost (represented as tentative_g) and update the records if a better path is found. The path is reversed in the output to display a set of numbered instructions to the goal. Only 2-4 neighbors are generated per state, and we only keep the lowest cost path to each state. 
